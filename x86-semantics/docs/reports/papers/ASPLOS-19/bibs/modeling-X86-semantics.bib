@article{Chlipala2008,
abstract = {We report on an experience using the Coq proof assistant to develop a program verification tool with a machine-checked proof of full correctness. The verifier is able to prove memory safety of x86 machine code programs compiled from code that uses algebraic datatypes. The tool's soundness theorem is expressed in terms of the bit-level semantics of x86 programs, so its correctness depends on very few assumptions. We take advantage of Coq's support for programming with dependent types and modules in the structure of the development. The approach is based on developing a library of reusable functors for transforming a verifier at one level of abstraction into a verifier at a lower level. Using this library, it is possible to prototype a verifier based on a new type system with a minimal amount of work, while obtaining a very strong soundness theorem about the final product.},
author = {Chlipala, Adam},
doi = {10.1017/S0956796808006904},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Chlipala - 2008 - Modular development of certified program verifiers with a proof assistant.pdf:pdf},
isbn = {1595933093},
issn = {09567968},
journal = {Journal of Functional Programming},
keywords = {dent types,interactive proof assistants,programming with depen-,proof-carrying code},
number = {5-6},
pages = {599--647},
title = {{Modular development of certified program verifiers with a proof assistant}},
volume = {18},
year = {2008}
}
@article{Kennedy2013,
abstract = {We describe a Coq formalization of a subset of the x86 architecture. One emphasis of the model is brevity: using dependent types, type classes and notation we give the x86 semantics a makeover that counters its reputation for baroqueness. We model bits},
author = {Kennedy, Andrew and Benton, Nick and Jensen, Jonas B. and Dagand, Pierre-Evariste},
doi = {10.1145/2505879.2505897},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Kennedy et al. - 2013 - Coq the world's best macro assembler.pdf:pdf},
isbn = {9781450321549},
issn = {00220000},
journal = {Proceedings of the 15th Symposium on Principles and Practice of Declarative Programming - PPDP '13},
pages = {13--24},
title = {{Coq: the world's best macro assembler?}},
url = {http://dl.acm.org/citation.cfm?doid=2505879.2505897},
year = {2013}
}

@article{Churchill,
author = {Churchill, Berkeley and Bastien, J F and Aiken, Alex},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Churchill, Bastien, Aiken - Unknown - Sound Loop Superoptimization for Google Native Client.pdf:pdf},
isbn = {9781450344654},
title = {{Sound Loop Superoptimization for Google Native Client}}
}

@article{Bansal2006,
abstract = {Peephole optimizers are typically constructed using human-written pattern matching rules, an approach that requires expertise and time, as well as being less than systematic at exploiting all oppor- tunities for optimization. We explore fully automatic construction of peephole optimizers using brute force superoptimization. While the optimizations discovered by our automatic system may be less general than human-written counterparts, our approach has the po- tential to automatically learn a database of thousands to millions of optimizations, in contrast to the hundreds found in current peep- hole optimizers.We show experimentally that our optimizer is able to exploit performance opportunities not found by existing com- pilers; in particular, we show speedups from 1.7 to a factor of 10 on some compute intensive kernels over a conventional optimizing compiler.},
author = {Bansal, Sorav and Aiken, Alex},
doi = {10.1145/1168919.1168906},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Bansal, Aiken - 2006 - Automatic generation of peephole superoptimizers.pdf:pdf},
isbn = {1595934510},
issn = {01635964},
journal = {ASPLOS 2006},
number = {5},
pages = {394},
title = {{Automatic generation of peephole superoptimizers}},
url = {http://portal.acm.org/citation.cfm?doid=1168919.1168906},
volume = {34},
year = {2006}
}
@article{Leroy2009,
abstract = {Purpose: We examined HIV testing behavior and its predictors among adolescents considered at high risk for HIV. Methods: Self-reports of HIV testing, knowledge, attitudes, and high-risk acts were examined among 272 adolescents aged 13-23 years (M = 18.7; SD = 2.3) attending community-based agencies that serve youth at high risk for HIV in Los Angeles, New York City, and San Francisco. Results: Evidence of adolescents' risk for HIV is reflected in a rate of 4.8{\%} seropositivity, 24{\%} injecting drug use, a mean of 4.3 (SD = 11.6) sexual partners during the previous 3 months, and 71{\%} condom use during vaginal/anal sex. HIV testing was common (63{\%}) and often repeated (M = 3.6, SD = 4.0). Knowledge of the meaning and consequences of testing was high (84{\%} correct). Contrary to service providers' expectations, youth were likely to return for their test results (90{\%} returned). Youth who were older, labeled themselves gay or bisexual, lived in Los Angeles or San Francisco, and those who injected drugs were significantly more likely, compared to peers, to get tested for HIV. Conclusions: These results suggest a need for more detailed observational studies of HIV testing behavior that include evaluation of characteristics of the youth, the testing site, and the attitudes and beliefs of providers offering HIV testing. (C) Society for Adolescent Medicine, 1997.},
author = {Leroy, Xavier},
doi = {10.1145/1538788.1538814},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Leroy - 2009 - Formal verification of a realistic compiler.pdf:pdf},
isbn = {0092070302238},
issn = {00010782},
journal = {Acm},
number = {7},
pages = {107},
title = {{Formal verification of a realistic compiler}},
volume = {52},
year = {2009}
}
@article{EricSchulteJasonRuchtiMattNoonanDavidCiarletta2018,
abstract = {—In this paper, we propose ABC, a real-time smart-phone Authentication protocol utilizing the photo-response non-uniformity (PRNU) of the Built-in Camera. In contrast to previous works that require tens of images to build reliable PRNU features for conventional cameras, we are the first to observe that one image alone can uniquely identify a smartphone due to the unique PRNU of a smartphone image sensor. This new discovery makes the use of PRNU practical for smartphone authentication. While most existing hardware fingerprints are vulnerable against forgery attacks, ABC defeats forgery attacks by verifying a smartphone's PRNU identity through a challenge response protocol using a visible light communication channel. A user captures two time-variant QR codes and sends the two images to a server, which verifies the identity by fingerprint and image content matching. The time-variant QR codes can also defeat replay attacks. Our experiments with 16,000 images over 40 smartphones show that ABC can efficiently authenticate user devices with an error rate less than 0.5{\%}.},
author = {{Eric Schulte, Jason Ruchti, Matt Noonan, David Ciarletta}, Alexey Loginov},
doi = {10.14722/ndss.2018.23xxx},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Eric Schulte, Jason Ruchti, Matt Noonan, David Ciarletta - 2018 - Evolving Exact Decompilation.pdf:pdf},
journal = {Ndss},
number = {February},
title = {{Evolving Exact Decompilation}},
url = {https://www.cs.unm.edu/{~}eschulte/data/bed.pdf{\%}0Ahttp://www.buffalo.edu/content/dam/www/news/photos/2017/12/ndss18-paper99.pdf},
year = {2018}
}

@article{Kim2017,
abstract = {—Binary lifting, which is to translate a binary exe-cutable to a high-level intermediate representation, is a primary step in binary analysis. Despite its importance, there are only few existing approaches to testing the correctness of binary lifters. Furthermore, the existing approaches suffer from low test cover-age, because they largely depend on random test case generation. In this paper, we present the design and implementation of the first systematic approach to testing binary lifters. We have evaluated the proposed system on 3 state-of-the-art binary lifters, and found 24 previously unknown semantic bugs. Our result demonstrates that writing a precise binary lifter is extremely difficult even for those heavily tested projects.},
author = {Kim, Soomin and Faerevaag, Markus and Jung, Minkyu and Jung, SeungIl and Oh, DongYeop and Lee, JongHyup and {Kil Cha}, Sang},
doi = {10.1109/ASE.2017.8115648},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Kim et al. - 2017 - Testing Intermediate Representations for Binary Analysis.pdf:pdf},
isbn = {9781538626849},
journal = {Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering},
pages = {353--364},
title = {{Testing Intermediate Representations for Binary Analysis}},
url = {https://dl.acm.org/citation.cfm?id=3155609{\%}0Ahttps://softsec.kaist.ac.kr/{~}soomink/paper/ase17main-mainp491-p.pdf},
year = {2017}
}
@article{Wang,
abstract = {—Software instrumentation techniques are widely used in program analysis tasks such as program profiling, vulnerability discovering, and security-oriented transforming. In this paper, we present an instrumentation tool called UROBOROS, which supports static instrumentation on stripped binaries. Due to the lack of relocation and debug information, reverse engineering of stripped binaries is challenging. Compared with the previous work, UROBOROS can provide complete, easy-to-use, transparent, and efficient static instrumentation on stripped binaries. UROBOROS supports complete instrumentation by stat-ically recovering the relocatable program (including both code and data sections) and the control flow structures from binary code. UROBOROS provides a rich API to access and manipulate different levels of the program structure. The instrumentation facilities of UROBOROS are easy-to-use, users with no binary rewriting and patching skills can directly manipulate stripped binaries to perform smooth program transformations. Distin-guished from most instrumentation tools that need to patch the instrumentation code as new sections, UROBOROS can directly inline the instrumentation code into the disassembled program, which provides transparent instrumentation on stripped binaries. For efficiency, in the rewritten output of existing tools, frequent control transfers between the attached and original sections can incur a considerable performance penalty. However, the output from UROBOROS incurs no extra cost because the original and in-strumentation code are connected by " fall-through " transfers. We perform comparative evaluations between UROBOROS and the state-of-the-art binary instrumentation tools, including DynInst and Pin. To demonstrate the versatility of UROBOROS, we also implement two real-world reengineering tasks which could be challenging for other instrumentation tools to accomplish. Our experimental results show that UROBOROS outperforms the existing binary instrumentation tools with better performance, lower labor cost, and a broader scope of applications.},
author = {Wang, Shuai and Wang, Pei and Wu, Dinghao},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Wang, Wang, Wu - Unknown - UROBOROS Instrumenting Stripped Binaries with Static Reassembling(2).pdf:pdf},
title = {{UROBOROS: Instrumenting Stripped Binaries with Static Reassembling}},
url = {https://faculty.ist.psu.edu/wu/papers/uroboros-api.pdf}
}
@article{GDSL:ENTCS12,
abstract = {The analysis of executable code requires the reconstruction of instructions from a sequence of bytes (or words) and a specification of their semantics. Most front-ends addressing this problem only support a single architecture, are bound to a specific programming language, or are hard to maintain. In this work, we present a domain specific language (DSL) called GDSL (Generic Decoder Specification Language) for specifying maintainable instruction decoders and the translation of instructions to a semantics. We motivate its design by illustrating its use for the Intel x86 platform. A compiler is presented that generates C code that rivals hand-crafted decoder implementations.},
author = {Sepp, Alexander and Kranz, Julian and Simon, Axel},
doi = {10.1016/j.entcs.2012.11.006},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {binary analysis,executable analysis,instruction decoder,program semantics},
pages = {53--64},
title = {{GDSL: A Generic Decoder Specification Language for Interpreting Machine Language}},
url = {https://ac.els-cdn.com/S157106611200076X/1-s2.0-S157106611200076X-main.pdf?{\_}tid=b53f79e7-bbca-4bab-87cf-3257df5dce83{\&}acdnat=1525120242{\_}54967b3656aa17ff2c7925ecd3550d25},
volume = {289},
year = {2012}
}
@article{Paleari2010a,
abstract = {The output of a disassembler is used for many different purposes (e.g., debugging and reverse engineering). Therefore, disassemblers represent the first link of a long chain of stages on which any high-level analysis of machine code depends upon. In this paper we demonstrate that many disassemblers fail to decode certain instructions and thus that the first link of the chain is very weak. We present a methodology, called N-version disassembly, to verify the correctness of disassemblers, based on differential analysis. Given a set of n - 1 disassemblers, we use them to decode fragments of machine code and we compare their output against each other. To further corroborate the output of these disassemblers, we developed a special instruction decoder, the nth, that delegates the decoding to the CPU, the ideal decoder. We tested eight of the most popular disassemblers for Intel x86, and found bugs in each of them.},
author = {Paleari, Roberto and Martignoni, Lorenzo and {Fresi Roglia}, Giampaolo and Bruschi, Danilo},
doi = {10.1145/1831708.1831741},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Paleari et al. - 2010 - N-version Disassembly Differential Testing of x86 Disassemblers(2).pdf:pdf},
isbn = {9781605588230},
journal = {Proceedings of the 19th international symposium on Software testing and analysis - ISSTA '10},
keywords = {automatic test generation,differential testing,software testing},
pages = {265},
title = {{N-version Disassembly: Differential Testing of x86 Disassemblers}},
url = {http://portal.acm.org/citation.cfm?doid=1831708.1831741},
year = {2010}
}
@article{Yee2009,
abstract = {This paper describes the design, implementation and evaluation of Native Client, a sandbox for untrusted x86 native code. Native Client aims to give browser-based applications the computational performance of native applications without compromising safety. Native Client uses software fault isolation and a secure runtime to direct system interaction and side effects through interfaces managed by Native Client. Native Client provides operating system portability for binary code while supporting performance-oriented features generally absent from Web application programming environments, such as thread support, instruction set extensions such as SSE, and use of compiler intrinsics and hand-coded assembler. We combine these properties in an open architecture that encourages community review and 3rd-party tools.},
author = {Yee, Bennet and Sehr, David and Dardyk, Gregory and Chen, J. Bradley and Muth, Robert and Ormandy, Tavis and Okasaka, Shiki and Narula, Neha and Fullagar, Nicholas},
doi = {10.1109/SP.2009.25},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Yee et al. - 2009 - Native client A sandbox for portable, untrusted x86 native code.pdf:pdf},
isbn = {9780769536330},
issn = {10816011},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
keywords = {NaCl},
mendeley-tags = {NaCl},
pages = {79--93},
title = {{Native client: A sandbox for portable, untrusted x86 native code}},
year = {2009}
}
@article{Reid2017a,
abstract = {Software and hardware are increasingly being formally verified against specifications, but how can we verify the specifications themselves? This paper explores what it means to formally verify a specification. We solve three challenges: (1) How to create a secondary, higher-level specification that can be effectively reviewed by processor designers who are not experts in formal verification; (2) How to avoid common-mode failures between the specifications; and (3) How to automatically verify the two specifications against each other. One of the most important specifications for software verification is the processor specification since it defines the behaviour of machine code and of hardware protection features used by operating systems. We demonstrate our approach on ARM's v8-M Processor Specification, which is intended to improve the security of Internet of Things devices. Thus, we focus on establishing the security guarantees the architecture is intended to provide. Despite the fact that the ARM v8-M specification had previously been extensively tested, we found twelve bugs (including two security bugs) that have all been fixed by ARM.},
author = {Reid, Alastair},
doi = {10.1145/3133912},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Reid - 2017 - Who guards the guards formal validation of the Arm v8-m architecture specification.pdf:pdf},
issn = {24751421},
journal = {OOPSLA},
keywords = {Formal Verification,ISA,Specification},
number = {OOPSLA},
pages = {1--24},
title = {{Who guards the guards? formal validation of the Arm v8-m architecture specification}},
url = {https://doi.org/10.1145/3133912{\%}0Ahttp://dl.acm.org/citation.cfm?doid=3152284.3133912},
volume = {1},
year = {2017}
}
@article{Roclsalt:PLDI12,
author = {Morrisett, Greg and Tan, Gang and Tassarotti, Joseph and Tristan, Jean-Baptiste and Gan, Edward},
doi = {10.1145/2254064.2254111},
isbn = {9781450312059},
issn = {0362-1340},
journal = {PLDI: Programming Languages Design and Implementation},
keywords = {2,4,d,domain-speci fi c languages,security,software engineer-,software fault isolation,veri fi cation},
pages = {395--404},
title = {{RockSalt: better, faster, stronger SFI for the x86}},
url = {http://doi.acm.org/10.1145/2254064.2254111{\%}5Cnhttp://dl.acm.org/ft{\_}gateway.cfm?id=2254111{\&}type=pdf},
year = {2012}
}
@inproceedings{Sarkar2008,
address = {New York, New York, USA},
author = {Sarkar, Susmit and Sewell, Peter and Nardelli, Francesco Zappa and Owens, Scott and Ridge, Tom and Braibant, Thomas and Myreen, Magnus O. and Alglave, Jade and Sarkar, Susmit and Sewell, Peter and Nardelli, Francesco Zappa and Owens, Scott and Ridge, Tom and Braibant, Thomas and Myreen, Magnus O. and Alglave, Jade},
booktitle = {Proceedings of the 36th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL '09},
doi = {10.1145/1480881.1480929},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Sarkar et al. - 2008 - The semantics of x86-CC multiprocessor machine code(2).pdf:pdf},
isbn = {9781605583792},
issn = {0362-1340},
keywords = {relaxed memory models,semantics},
number = {1},
pages = {379},
publisher = {ACM Press},
title = {{The semantics of x86-CC multiprocessor machine code}},
url = {http://portal.acm.org/citation.cfm?doid=1480881.1480929},
volume = {44},
year = {2008}
}

@article{Modern2018,
author = {Modern, Introduction and Validation, Translation},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Modern, Validation - 2018 - Cross-Language Program Equivalence with Application to.pdf:pdf},
number = {1},
title = {{Cross-Language Program Equivalence with Application to}},
volume = {1},
year = {2018}
}
@article{Robbins2016,
abstract = {Reconstructing the meaning of a program from its binary executable is known as reverse engineering; it has a wide range of applications in software security, exposing piracy, legacy systems, etc. Since reversing is ultimately a search for meaning, there is much interest in inferring a type (a meaning) for the elements of a binary in a consistent way. Unfortunately existing approaches do not guarantee any semantic relevance for their reconstructed types. This paper presents a new and semantically-founded approach that provides strong guarantees for the reconstructed types. Key to our approach is the derivation of a witness program in a high-level language alongside the reconstructed types. This witness has the same semantics as the binary, is type correct by construction, and it induces a (justifiable) type assignment on the binary. Moreover, the approach effectively yields a type-directed decompiler. We formalise and implement the approach for reversing MinX, an abstraction of x86, to MinC, a type-safe dialect of C with recursive datatypes. Our evaluation compiles a range of textbook C algorithms to MinX and then recovers the original structures.},
author = {Robbins, Ed and King, Andy and Schrijvers, Tom},
doi = {10.1145/2914770.2837633},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Robbins, King, Schrijvers - 2016 - From MinX to MinC semantics-driven decompilation of recursive datatypes.pdf:pdf},
isbn = {1595930566},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {decompilation,recursive datatypes,reverse engineering},
number = {1},
pages = {191--203},
title = {{From MinX to MinC: semantics-driven decompilation of recursive datatypes}},
url = {http://dl.acm.org/citation.cfm?doid=2914770.2837633},
volume = {51},
year = {2016}
}

@article{Schkufza2016,
abstract = {The optimization of short sequences of loop-free, fixed-point assembly code sequences is an important problem in high-performance computing. However, the competing constraints of transformation correctness and performance improve-ment often force even special purpose compilers to pro-duce sub-optimal code. We show that by encoding these constraints as terms in a cost function, and using a Markov Chain Monte Carlo sampler to rapidly explore the space of all possible code sequences, we are able to generate aggres-sively optimized versions of a given target code sequence. Beginning from binaries compiled by llvm −O0, we are able to produce provably correct code sequences that either match or outperform the code produced by gcc −O3, icc −O3, and in some cases expert handwritten assembly. 1. INTRODUCTION For many application domains there is considerable value in producing the most performant code possible. However, the traditional structure of a compiler's optimization phase is ill-suited to this task. Factoring the optimization problem into a collection of small subproblems that can be solved independently—although suitable for generating consis-tently good code—can lead to sub-optimal results. In many cases, the best possible code can only be obtained through the simultaneous consideration of mutually dependent issues such as instruction selection, register allocation, and target-dependent optimization. Previous approaches to this problem have focused on the exploration of all possibilities within some limited class of code sequences. In contrast to a traditional compiler, which uses performance constraints to drive the generation of a sin-gle sequence, these systems consider multiple sequences and select the one that is best able to satisfy those constraints. An attractive feature of this approach is completeness: if a code sequence exists that meets the desired constraints it is guar-anteed to be found. However, completeness also places prac-tical limitations on the type of code that can be considered. These techniques are either limited to sequences that are shorter than the threshold at which many interesting optimi-zations take place or code written in simplified languages. We overcome this limitation through the use of incom-plete search: the competing requirements of correctness and performance improvement are encoded as terms in a cost function which is defined over the space of all loop-free x86{\_}64 instruction sequences, and the optimization task is formulated as a cost minimization problem. While the search space is highly irregular and not amenable to exact optimization techniques, we show that the com-mon approach of employing a Markov Chain Monte Carlo (MCMC) sampler to explore the function and produce low-cost samples is sufficient for producing high-quality code.},
author = {Schkufza, Eric and Sharma, Rahul and Aiken, Alex},
doi = {10.1145/2863701},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Schkufza, Sharma, Aiken - 2016 - Stochastic program optimization.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
number = {2},
pages = {114--122},
title = {{Stochastic program optimization}},
url = {http://dl.acm.org/citation.cfm?doid=2886013.2863701},
volume = {59},
year = {2016}
}
@article{Srinivasan2015b,
author = {Srinivasan, Venkatesh and Reps, Thomas and Srinivasan, Venkatesh and Reps, Thomas},
doi = {10.1145/2858965.2814321},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Srinivasan et al. - 2015 - Partial evaluation of machine code.pdf:pdf},
isbn = {978-1-4503-3689-5},
issn = {03621340},
journal = {OOPSLA 2015:Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
keywords = {BTA,IA-32 instruction set,Partial evaluation,machine code,machine-code synthesis,specialization},
number = {10},
pages = {860--879},
title = {{Partial evaluation of machine code}},
url = {http://dl.acm.org/citation.cfm?doid=2858965.2814321},
volume = {50},
year = {2015}
}
@article{Reid2017,
author = {Reid, Alastair},
doi = {10.1109/FMCAD.2016.7886675},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Reid - 2017 - Trustworthy specifications of ARM{\textregistered} v8-A and v8-M system level architecture.pdf:pdf},
isbn = {9780983567868},
journal = {Proceedings of the 16th Conference on Formal Methods in Computer-Aided Design, FMCAD 2016},
pages = {161--168},
title = {{Trustworthy specifications of ARM{\textregistered} v8-A and v8-M system level architecture}},
year = {2017}
}

@inproceedings{Heule2016a,
 author = {Heule, Stefan and Schkufza, Eric and Sharma, Rahul and Aiken, Alex},
 title = {Stratified Synthesis: Automatically Learning the x86-64 Instruction Set},
 booktitle = {Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation},
 series = {PLDI '16},
 year = {2016},
 isbn = {978-1-4503-4261-2},
 location = {Santa Barbara, CA, USA},
 pages = {237--250},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/2908080.2908121},
 doi = {10.1145/2908080.2908121},
 acmid = {2908121},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {ISA specification, program synthesis, x86-64},
}

@article{Reid2016,
abstract = {Although testing is the most widely used technique to control the quality of software systems, it is a topic that, until relatively recently, has received scant attention from the computer research community. Although some pioneering work was already done a considerable time ago [Cho78,GG83,How78,Mye79], the testing of software systems has never become a mainstream activity of scientific research. The reasons that are given to explain this situation usually include arguments to the effect that testing as a technique is inferior to verification — testing can show only the presence of errors, not their absence — and that we should therefore concentrate on developing theory and tools for the latter. It has also been frequently said that testing is by its very nature a non-formal activity, where formal methods and related tools are at best of little use. The first argument is incorrect in the sense that it gives an incomplete picture of the situation. Testing is inferior to verification if the verification model can be assumed to be correct and if its complexity can be handled correctly by the person and or tool involved in the verification task. If these conditions are not fulfilled, which is frequently the case, then testing is often the only available technique to increase the confidence in the correctness of a system. In this talk we will show that the second argument is flawed as well. It is based on the identification of testing with robustness testing, where it is precisely the objective to find out how the system behaves under unspecified circumstances. This excludes the important activity of conformance testing, which tries to test the extent to which system behaviour conforms to its specification. It is precisely in this area where formal methods and tools can help to derive tests systematically from specifications, which is a great improvement over laborious, error-prone and costly manual test derivation. In our talk we show how the process algebraic testing theory due to De Nicola and Hennessy [DNH84,DeN87], originally conceived out of semantic considerations, may be used to obtain principles for test derivation. We will give an overview of the evolution of these ideas over the past ten years or so, starting with the conformance testing theory of simple synchronously communicating reactive systems [Bri88,Lan90] and leading to realistic systems that involve sophisticated asynchronous message passing mechanisms [Tre96,HT97]. Written accounts can be found in [BHT97,He98]. We discuss how such ideas have been used to obtain modern test derivation tools, such as TVEDA and TGV [Pha94, CGPT96,FJJV96], and the tool set that is currently being developed in the C{\^{o}}te-de-Resyste project [STW96]. The advantage of a test theory that is based on well-established process algebraic theory is that in principle there exists a clear link between testing and verification, which allows the areas to share ideas and algorithms [FJJV96,VT98]. Time allowing, we look at some of the methodological differences and commonalities between model checking techniques and testing, one of the differences being that of state space coverage, and an important commonality that of test property selection. In recent years the research into the use of formal methods and tools for testing reactive systems has seen a considerable growth. An overview of different approaches and school of thought can be found in [BPS98], reporting on the first ever Dagstuhl seminar devoted to testing. The formal treatment of conformance testing based on process algebra and/or concurrency theory is certainly not the only viable approach. An important school of thought is the FSM-testing theory grown out of the seminal work of Chow [Cho78], of which a good overview is given in [LY96]. Another interesting formal approach to testing is based on abstract data type theory [Gau95,BGM91].},
archivePrefix = {arXiv},
arxivId = {1301.4779},
author = {Reid, Alastair and Chen, Rick and Deligiannis, Anastasios and Gilday, David and Hoyes, David and Keen, Will and Pathirane, Ashan and Shepherd, Owen and Vrabel, Peter and Zaidi, Ali},
doi = {10.1007/978-3-319-41540-6_3},
eprint = {1301.4779},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Reid et al. - 2016 - End-to-end verification of ARM{\textregistered} processors with ISA-formal.pdf:pdf},
isbn = {9783319415390},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {42--58},
pmid = {4520227},
title = {{End-to-end verification of ARM{\textregistered} processors with ISA-formal}},
volume = {9780},
year = {2016}
}
@article{Zhang,
abstract = {Control-Flow Integrity (CFI) has been recognized as an important low-level security property. Its enforcement can defeat most injected and existing code attacks, in-cluding those based on Return-Oriented Programming (ROP). Previous implementations of CFI have required compiler support or the presence of relocation or debug information in the binary. In contrast, we present a tech-nique for applying CFI to stripped binaries on x86/Linux. Ours is the first work to apply CFI to complex shared libraries such as glibc. Through experimental evalu-ation, we demonstrate that our CFI implementation is effective against control-flow hijack attacks, and elimi-nates the vast majority of ROP gadgets. To achieve this result, we have developed robust techniques for disas-sembly, static analysis, and transformation of large bina-ries. Our techniques have been tested on over 300MB of binaries (executables and shared libraries).},
author = {Zhang, Mingwei and Sekar, R},
file = {:home/sdasgup3/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Zhang, Sekar - Unknown - Control Flow Integrity for COTS Binaries Control Flow Integrity for COTS Binaries.pdf:pdf},
isbn = {978-1-931971-03-4},
title = {{Control Flow Integrity for COTS Binaries Control Flow Integrity for COTS Binaries *}},
url = {https://www.usenix.org/system/files/conference/usenixsecurity13/sec13-paper{\_}zhang.pdf}
}

@inproceedings{Stoke2013,
 author = {Schkufza, Eric and Sharma, Rahul and Aiken, Alex},
 title = {Stochastic Superoptimization},
 booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS '13},
 year = {2013},
 isbn = {978-1-4503-1870-9},
 location = {Houston, Texas, USA},
 pages = {305--316},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/2451116.2451150},
 doi = {10.1145/2451116.2451150},
 acmid = {2451150},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {64-bit, binary, markov chain monte carlo, mcmc, smt, stochastic search, superoptimization, x86, x86-64},
}

@inproceedings{Goel:FMCAD14,
 author = {Goel, Shilpi and Hunt, Warren A. and Kaufmann, Matt and Ghosh, Soumava},
 title = {Simulation and Formal Verification of x86 Machine-Code Programs That Make System Calls},
 booktitle = {Proceedings of the 14th Conference on Formal Methods in Computer-Aided Design},
 series = {FMCAD '14},
 year = {2014},
 isbn = {978-0-9835678-4-4},
 location = {Lausanne, Switzerland},
 pages = {18:91--18:98},
 articleno = {18},
 numpages = {8},
 url = {http://dl.acm.org/citation.cfm?id=2682923.2682944},
 acmid = {2682944},
 publisher = {FMCAD Inc},
 address = {Austin, TX},
}

@Inbook{Goel:ProCoS17,
author="Goel, Shilpi
and Hunt, Warren A.
and Kaufmann, Matt",
editor="Hinchey, Mike
and Bowen, Jonathan P.
and Olderog, Ernst-R{\"u}diger",
title="Engineering a Formal, Executable x86 ISA Simulator for Software Verification",
bookTitle="Provably Correct Systems",
year="2017",
publisher="Springer International Publishing",
address="Cham",
pages="173--209",
isbn="978-3-319-48628-4",
doi="10.1007/978-3-319-48628-4_8",
url="https://doi.org/10.1007/978-3-319-48628-4_8"
}

@inproceedings{Goel:VTTE13:ACP:2958657.2958669,
 author = {Goel, Shilpi and Hunt, Warren A.},
 title = {Automated Code Proofs on a Formal Model of the X86},
 booktitle = {Revised Selected Papers of the 5th International Conference on Verified Software: Theories, Tools, Experiments - Volume 8164},
 series = {VSTTE 2013},
 year = {2014},
 isbn = {978-3-642-54107-0},
 location = {Menlo Park, CA, USA},
 pages = {222--241},
 numpages = {20},
 url = {http://dx.doi.org/10.1007/978-3-642-54108-7_12},
 doi = {10.1007/978-3-642-54108-7_12},
 acmid = {2958669},
 publisher = {Springer-Verlag New York, Inc.},
 address = {New York, NY, USA},
}

@article{Ulan:Article12,
author = {Degenbaev, Ulan},
year = {2012},
month = {03},
pages = {},
title = {Formal specification of the x86 instruction set architecture},
url = {https://core.ac.uk/download/pdf/10697957.pdf},
}

@article{article,
author = {Ray, Sandip},
year = {2018},
month = {07},
pages = {},
title = {Towards a Formalization of the X86 Instruction Set Architecture},
url = {http://www.cs.utexas.edu/users/sandip/publications/x86-08/x86-rings.pdf},
}

@article{McSema:Recon14,
author = {Ruef, Andrew and Dinaburg, Artem},
journal = {REcon},
title = {{Static Translation of X86 Instruction Semantics to LLVM with McSema}},
url = {\url{https://github.com/trailofbits/mcsema}},
year = {2014}
}

@inproceedings{QEMU:USENIX05,
 author = {Bellard, Fabrice},
 title = {QEMU, a Fast and Portable Dynamic Translator},
 booktitle = {Proceedings of the Annual Conference on USENIX Annual Technical Conference},
 series = {ATEC '05},
 year = {2005},
 location = {Anaheim, CA},
 pages = {41--41},
 numpages = {1},
 url = {http://dl.acm.org/citation.cfm?id=1247360.1247401},
 acmid = {1247401},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
}

@article{Valgrind:ENTCS03,
title = "Valgrind: A Program Supervision Framework",
journal = "Electronic Notes in Theoretical Computer Science",
volume = "89",
number = "2",
pages = "44 - 66",
year = "2003",
note = "RV '2003, Run-time Verification (Satellite Workshop of CAV '03)",
issn = "1571-0661",
doi = "https://doi.org/10.1016/S1571-0661(04)81042-9",
url = "http://www.sciencedirect.com/science/article/pii/S1571066104810429",
author = "Nicholas Nethercote and Julian Seward"
}

@inproceedings{BAP:CAV11,
 author = {Brumley, David and Jager, Ivan and Avgerinos, Thanassis and Schwartz, Edward J.},
 title = {BAP: A Binary Analysis Platform},
 booktitle = {Proceedings of the 23rd International Conference on Computer Aided Verification},
 series = {CAV'11},
 year = {2011},
 isbn = {978-3-642-22109-5},
 location = {Snowbird, UT},
 pages = {463--469},
 numpages = {7},
 url = {http://dl.acm.org/citation.cfm?id=2032305.2032342},
 acmid = {2032342},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
}

@Misc{Radare2,
  title = {{Radare2}},
  howpublished = {\url{https://rada.re/r/}},
  author = "Alvarez, Sergi",
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}

@Misc{ESIL,
  title = {{Evaluable Strings Intermediate Language}},
  howpublished = {\url{https://radare.gitbooks.io/radare2book/content/disassembling/esil.html}},
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}

@Misc{Angr,
  title={{Angr: A powerful and user-friendly binary analysis platform!}},
  howpublished = {\url{http://angr.io/}},
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}

@article{Angr1,
  title={SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis},
  author={Shoshitaishvili, Yan and Wang, Ruoyu and Salls, Christopher and Stephens, Nick and Polino, Mario and Dutcher, Audrey and Grosen, John and Feng, Siji and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
  booktitle={IEEE Symposium on Security and Privacy},
  year={2016}
}

@article{Angr2,
  title={Driller: Augmenting Fuzzing Through Selective Symbolic Execution},
  author={Stephens, Nick and Grosen, John and Salls, Christopher and Dutcher, Audrey and Wang, Ruoyu and Corbetta, Jacopo and Shoshitaishvili, Yan and Kruegel, Christopher and Vigna, Giovanni},
  booktitle={NDSS},
  year={2016}
}

@article{Angr3,
  title={Firmalice - Automatic Detection of Authentication Bypass Vulnerabilities in Binary Firmware},
  author={Shoshitaishvili, Yan and Wang, Ruoyu and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
  booktitle={NDSS},
  year={2015}
}

@Misc{Remill,
  title = 	 {Remill: Library for lifting of x86, amd64, and aarch64 machine code to LLVM bitcode},
  howpublished = {\url{https://github.com/trailofbits/remill}},
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}

@Misc{FCD,
  title = 	 {fcd: An optimizing decompiler},
  howpublished = {\url{https://zneak.github.io/fcd/}},
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}


@article{TSL:TOPLAS13,
 author = {Lim, Junghee and Reps, Thomas},
 title = {{TSL: A System for Generating Abstract Interpreters and Its Application to Machine-Code Analysis}},
 journal = {ACM Trans. Program. Lang. Syst.},
 issue_date = {April 2013},
 volume = {35},
 number = {1},
 month = apr,
 year = {2013},
 issn = {0164-0925},
 pages = {4:1--4:59},
 articleno = {4},
 numpages = {59},
 url = {http://doi.acm.org/10.1145/2450136.2450139},
 doi = {10.1145/2450136.2450139},
 acmid = {2450139},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Abstract interpretation, dataflow analysis, dynamic analysis, machine-code analysis, static analysis, symbolic analysis},
}

@inproceedings{Hasabnis:ASPLOS16,
 author = {Hasabnis, Niranjan and Sekar, R.},
 title = {Lifting Assembly to Intermediate Representation: A Novel Approach Leveraging Compilers},
 booktitle = {Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS '16},
 year = {2016},
 isbn = {978-1-4503-4091-5},
 location = {Atlanta, Georgia, USA},
 pages = {311--324},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/2872362.2872380},
 doi = {10.1145/2872362.2872380},
 acmid = {2872380},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@inproceedings{Hasabnis:FSE16,
 author = {Hasabnis, Niranjan and Sekar, R.},
 title = {Extracting Instruction Semantics via Symbolic Execution of Code Generators},
 booktitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
 series = {FSE 2016},
 year = {2016},
 isbn = {978-1-4503-4218-6},
 location = {Seattle, WA, USA},
 pages = {301--313},
 numpages = {13},
 url = {http://doi.acm.org/10.1145/2950290.2950335},
 doi = {10.1145/2950290.2950335},
 acmid = {2950335},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Code generators, Instruction-set semantics extraction, Symbolic execution},
} 

@inproceedings{CompCert:FM06,
  author = {Sandrine Blazy and Zaynah Dargaye and Xavier Leroy},
  title = {Formal Verification of a {C} Compiler Front-End},
  booktitle = {FM 2006: Int. Symp. on Formal Methods},
  series = {Lecture Notes in Computer Science},
  publisher = {Springer},
  volume = 4085,
  year = 2006,
  pages = {460--475},
  url = {http://xavierleroy.org/publi/cfront.pdf},
  urlpublisher = {http://dx.doi.org/10.1007/11813040_31},
  hal = {http://hal.inria.fr/inria-00106401/},
  pubkind = {conf-int-multi}
}

@book{ACL2:Kaufmann2000,
 author = {Kaufmann, Matt and Moore, J. Strother and Manolios, Panagiotis},
 title = {Computer-Aided Reasoning: An Approach},
 year = {2000},
 isbn = {0792377443},
 publisher = {Kluwer Academic Publishers},
 address = {Norwell, MA, USA},
}

@Misc{GoelList,
  title = 	 {{X86isa: Implemented-opcodes: Opcodes supported by the x86 model}},
  howpublished = {\url{http://www.cs.utexas.edu/users/moore/acl2/manuals/current/manual/index-seo.php/X86ISA____IMPLEMENTED-OPCODES}},
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}

@InProceedings{LLVM:CGO04,
    author    = {Chris Lattner and Vikram Adve},
    title     = "{LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation}",
    booktitle = "{Proceedings of the 2004 International Symposium on Code Generation and Optimization (CGO'04)}",
    address   = {Palo Alto, California},
    month     = {Mar},
    year      = {2004}
}

@inproceedings{Pin:2005,
 author = {Luk, Chi-Keung and Cohn, Robert and Muth, Robert and Patil, Harish and Klauser, Artur and Lowney, Geoff and Wallace, Steven and Reddi, Vijay Janapa and Hazelwood, Kim},
 title = {Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation},
 booktitle = {Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation},
 series = {PLDI '05},
 year = {2005},
 isbn = {1-59593-056-6},
 location = {Chicago, IL, USA},
 pages = {190--200},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/1065010.1065034},
 doi = {10.1145/1065010.1065034},
 acmid = {1065034},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {dynamic compilation, instrumentation, program analysis tools},
}

@phdthesis{DynamoRIO:2004,
 author = {Bruening, Derek L.},
 title = {Efficient, Transparent, and Comprehensive Runtime Code Manipulation},
 year = {2004},
 note = {AAI0807735},
 publisher = {Massachusetts Institute of Technology},
 address = {Cambridge, MA, USA},
}

@inproceedings{BitBlaze:2008,
 author = {Song, Dawn and Brumley, David and Yin, Heng and Caballero, Juan and Jager, Ivan and Kang, Min Gyung and Liang, Zhenkai and Newsome, James and Poosankam, Pongsin and Saxena, Prateek},
 title = {BitBlaze: A New Approach to Computer Security via Binary Analysis},
 booktitle = {Proceedings of the 4th International Conference on Information Systems Security},
 series = {ICISS '08},
 year = {2008},
 isbn = {978-3-540-89861-0},
 location = {Hyderabad, India},
 pages = {1--25},
 numpages = {25},
 url = {http://dx.doi.org/10.1007/978-3-540-89862-7_1},
 doi = {10.1007/978-3-540-89862-7_1},
 acmid = {1496257},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
 keywords = {Binary analysis, malware analysis and defense, reverse engineering, vulnerability analysis and defense},
}

@inproceedings{Egele:USENIX07,
 author = {Egele, Manuel and Kruegel, Christopher and Kirda, Engin and Yin, Heng and Song, Dawn},
 title = {Dynamic Spyware Analysis},
 booktitle = {2007 USENIX Annual Technical Conference on Proceedings of the USENIX Annual Technical Conference},
 series = {ATC'07},
 year = {2007},
 isbn = {999-8888-77-6},
 location = {Santa Clara, CA},
 pages = {18:1--18:14},
 articleno = {18},
 numpages = {14},
 url = {http://dl.acm.org/citation.cfm?id=1364385.1364403},
 acmid = {1364403},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
}

@inproceedings{Yin:CCS07,
 author = {Yin, Heng and Song, Dawn and Egele, Manuel and Kruegel, Christopher and Kirda, Engin},
 title = {Panorama: Capturing System-wide Information Flow for Malware Detection and Analysis},
 booktitle = {Proceedings of the 14th ACM Conference on Computer and Communications Security},
 series = {CCS '07},
 year = {2007},
 isbn = {978-1-59593-703-2},
 location = {Alexandria, Virginia, USA},
 pages = {116--127},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1315245.1315261},
 doi = {10.1145/1315245.1315261},
 acmid = {1315261},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {dynamic taint analysis, malware analysis, malware detection, spyware},
}

@inproceedings{Kiriansky:2002:SEV,
 author = {Kiriansky, Vladimir and Bruening, Derek and Amarasinghe, Saman P.},
 title = {Secure Execution via Program Shepherding},
 booktitle = {Proceedings of the 11th USENIX Security Symposium},
 year = {2002},
 isbn = {1-931971-00-5},
 pages = {191--206},
 numpages = {16},
 url = {http://dl.acm.org/citation.cfm?id=647253.720293},
 acmid = {720293},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
}

@inproceedings{Erlingsson:2006,
 author = {Erlingsson, \'{U}lfar and Abadi, Mart\'{\i}n and Vrable, Michael and Budiu, Mihai and Necula, George C.},
 title = {XFI: Software Guards for System Address Spaces},
 booktitle = {Proceedings of the 7th Symposium on Operating Systems Design and Implementation},
 series = {OSDI '06},
 year = {2006},
 isbn = {1-931971-47-1},
 location = {Seattle, Washington},
 pages = {75--88},
 numpages = {14},
 url = {http://dl.acm.org/citation.cfm?id=1298455.1298463},
 acmid = {1298463},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
}

@inproceedings{Yee:2009,
 author = {Yee, Bennet and Sehr, David and Dardyk, Gregory and Chen, J. Bradley and Muth, Robert and Ormandy, Tavis and Okasaka, Shiki and Narula, Neha and Fullagar, Nicholas},
 title = {Native Client: A Sandbox for Portable, Untrusted x86 Native Code},
 booktitle = {Proceedings of the 2009 30th IEEE Symposium on Security and Privacy},
 series = {SP '09},
 year = {2009},
 isbn = {978-0-7695-3633-0},
 pages = {79--93},
 numpages = {15},
 url = {https://doi.org/10.1109/SP.2009.25},
 doi = {10.1109/SP.2009.25},
 acmid = {1608126},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 keywords = {Security, World Wide Web},
}

@article{Srinivasan2015,
author = {Srinivasan, Venkatesh and Reps, Thomas},
doi = {10.1145/2737924.2737960},
isbn = {9781450334686},
issn = {15232867},
journal = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation - PLDI 2015},
keywords = {1,2,about the properties of,analysis,another potential use of,automatic pro-,binaries,cegis,d,divide-and-conquer,i,ia-32 instruction set,machine-code synthesis,smt},
pages = {596--607},
title = {{Synthesis of machine code from semantics}},
url = {http://dl.acm.org/citation.cfm?doid=2737924.2737960},
year = {2015}
}

@inproceedings{Amit:SOSP15,
 author = {Amit, Nadav and Tsafrir, Dan and Schuster, Assaf and Ayoub, Ahmad and Shlomo, Eran},
 title = {Virtual CPU Validation},
 booktitle = {Proceedings of the 25th Symposium on Operating Systems Principles},
 series = {SOSP '15},
 year = {2015},
 isbn = {978-1-4503-3834-9},
 location = {Monterey, California},
 pages = {311--327},
 numpages = {17},
 url = {http://doi.acm.org/10.1145/2815400.2815420},
 doi = {10.1145/2815400.2815420},
 acmid = {2815420},
 publisher = {ACM},
 address = {New York, NY, USA},
} 

@Misc{IntelManual,
  title = 	 {{Intel 64 and IA-32 Architectures Software Developer Manuals}},
  howpublished =
  {\url{https://software.intel.com/en-us/articles/intel-sdm}},
  note = 	 {Published on October 12, 2016, updated May 18, 2018.}
}

@Misc{smtlib,
  title = 	 {{SMT-LIB:  Satisfiability Modulo Theories}},
  howpublished =
  {\url{http://smtlib.cs.uiowa.edu/index.shtml}},
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}

@Misc{GNUAS,
  title = 	 {{Using as}},
  howpublished =
  {\url{https://sourceware.org/binutils/docs/as/}},
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}

@Misc{GDB,
  title = 	 {{GDB: The GNU Project Debugger}},
  howpublished =
  {\url{https://www.gnu.org/software/gdb/}},
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}

@Misc{Objdump,
  title = 	 {{objdump(1) - Linux man page}},
  howpublished =
  {\url{https://linux.die.net/man/1/objdump}},
  month = 	 {July},
  year = 	 {2018},
  note = 	 {Last accessed}
}

@article{WYSINWYE,
 author = {Balakrishnan, Gogul and Reps, Thomas},
 title = {{WYSINWYX: What You See is Not What You eXecute}},
 journal = {ACM Trans. Program. Lang. Syst.},
 issue_date = {August 2010},
 volume = {32},
 number = {6},
 month = aug,
 year = {2010},
 issn = {0164-0925},
 pages = {23:1--23:84},
 articleno = {23},
 numpages = {84},
 url = {http://doi.acm.org/10.1145/1749608.1749612},
 doi = {10.1145/1749608.1749612},
 acmid = {1749612},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Abstract interpretation, context-sensitive analysis, data structure recovery, interprocedural dataflow analysis, pointer analysis, reverse engineering, static analysis},
}

@article{Thompson,
 author = {Thompson, Ken},
 title = {{Reflections on Trusting Trust}},
 journal = {Commun. ACM},
 issue_date = {Aug 1984},
 volume = {27},
 number = {8},
 month = aug,
 year = {1984},
 issn = {0001-0782},
 pages = {761--763},
 numpages = {3},
 url = {http://doi.acm.org/10.1145/358198.358210},
 doi = {10.1145/358198.358210},
 acmid = {358210},
 publisher = {ACM},
 address = {New York, NY, USA},
}


@inproceedings{DeMoura:2008,
 author = {De Moura, Leonardo and Bj{\o}rner, Nikolaj},
 title = {Z3: An Efficient SMT Solver},
 booktitle = {Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
 series = {TACAS'08/ETAPS'08},
 year = {2008},
 isbn = {3-540-78799-2, 978-3-540-78799-0},
 location = {Budapest, Hungary},
 pages = {337--340},
 numpages = {4},
 url = {http://dl.acm.org/citation.cfm?id=1792734.1792766},
 acmid = {1792766},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
}
